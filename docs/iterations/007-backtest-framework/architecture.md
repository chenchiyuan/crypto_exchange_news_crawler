# Volume Trap 策略回测框架 - 架构设计文档

## 阶段一：需求解读与目标对齐

### 我的理解：

**核心业务目标**：
构建一个Volume Trap策略回测分析系统，为量化交易者提供科学衡量做空策略有效性的工具。系统需要分析发现"弃盘"异常事件后的价格表现，量化评估做空策略的风险和收益指标，并为策略优化提供数据支撑。

**关键用户流程**：
1. **发现异常事件**：现有Volume Trap检测系统识别"疑似弃盘"或"确定弃盘"的异常事件
2. **离线批量回测**：使用Django管理命令执行批量回测，离线计算所有异常事件的后续表现
3. **数据持久化**：回测结果自动存储到数据库，包括单个事件分析和整体统计
4. **前端展示**：单个事件详情页展示K线图和关键指标，整体统计面板展示策略表现
5. **策略评估**：通过胜率、盈亏比、平均收益等指标评估做空策略有效性

**核心策略参数**：
- **入场时机**：异常事件触发后，下一根K线收盘价做空
- **持仓策略**：持续持仓，不主动平仓（观察全部历史数据或可配置截止时间）
- **反弹标准**：从最低点后价格上涨超过20%视为显著反弹
- **分析维度**：单个事件表现 + 整体策略表现

---

## 阶段二：架构设计与可视化

### 核心架构图
```mermaid
graph TB
    %% 前端层
    subgraph "前端层"
        UI1[单个事件详情页<br/>K线图+指标面板]
        UI2[整体统计面板<br/>胜率+收益分布]
        UI3[回测结果列表<br/>查询+筛选]
    end

    %% API层
    subgraph "API层"
        API1[回测详情API<br/>GET /backtest/{id}/]
        API2[批量查询API<br/>GET /backtest/]
        API3[统计API<br/>GET /statistics/]
    end

    %% 服务层
    subgraph "服务层"
        SVC1[BacktestResultService<br/>回测结果服务]
        SVC2[StatisticsService<br/>统计服务]
        SVC3[ChartDataService<br/>图表数据服务]
    end

    %% 业务逻辑层
    subgraph "业务逻辑层"
        BL1[数据查询逻辑<br/>• 分页查询<br/>• 条件筛选<br/>• 排序]
        BL2[指标聚合逻辑<br/>• 胜率计算<br/>• 收益统计<br/>• 回撤分析]
        BL3[图表数据转换<br/>• K线数据格式化<br/>• 关键点标注]
    end

    %% 离线回测层
    subgraph "离线回测层"
        CMD[回测管理命令<br/>python manage.py run_backtest]
        BATCH[批量回测器<br/>BatchBacktestRunner]
        ENGINE[回测引擎<br/>VolumeTrapBacktestEngine]
    end

    %% 数据层
    subgraph "数据层"
        subgraph "现有数据"
            DB1[KLine<br/>历史K线数据]
            DB2[VolumeTrapMonitor<br/>异常事件记录]
        end

        subgraph "回测数据"
            DB3[BacktestResult<br/>单个回测结果]
            DB4[BacktestStatistics<br/>整体统计]
        end
    end

    %% 连接关系 - 在线展示
    UI1 --> API1
    UI2 --> API3
    UI3 --> API2

    API1 --> SVC1
    API2 --> SVC1
    API3 --> SVC2

    SVC1 --> BL1
    SVC2 --> BL2
    SVC3 --> BL3

    SVC1 --> DB3
    SVC2 --> DB3
    SVC2 --> DB4
    SVC3 --> DB3
    SVC3 --> DB1

    %% 连接关系 - 离线回测
    CMD --> BATCH
    BATCH --> ENGINE
    ENGINE --> DB1
    ENGINE --> DB2
    ENGINE --> DB3

    %% 样式
    classDef frontend fill:#e1f5fe
    classDef api fill:#f3e5f5
    classDef service fill:#e8f5e9
    classDef logic fill:#fff3e0
    classDef batch fill:#f1f8e9
    classDef data fill:#fce4ec
    classDef existing fill:#f5f5f5

    class UI1,UI2,UI3 frontend
    class API1,API2,API3 api
    class SVC1,SVC2,SVC3 service
    class BL1,BL2,BL3 logic
    class CMD,BATCH,ENGINE batch
    class DB3,DB4 data
    class DB1,DB2 existing
```

### 概念解读
本架构采用**离线回测 + 在线展示**的分离式设计。通过Django管理命令执行批量回测，将结果存储到数据库；前端仅负责查询和展示回测结果。这种设计避免了复杂的异步任务处理，简化了系统架构，同时保证了批量回测的稳定性和性能。

### 组件职责

**前端层组件**：
- **单个事件详情页**：展示特定异常事件的完整回测分析，包括K线图（标注入场点、最低点、反弹点）和关键指标面板
- **整体统计面板**：展示策略的聚合统计，包括胜率、盈亏比等关键指标卡片、收益分布图、回撤分析图
- **回测结果列表**：提供回测结果的查询和浏览功能，支持分页、排序、筛选

**API层组件**：
- **回测详情API**：获取单个回测详情，支持前端详情页展示
- **批量查询API**：查询回测结果列表，支持分页、排序、筛选条件
- **统计API**：获取整体策略统计数据，支持多维度分析

**服务层组件**：
- **BacktestResultService**：回测结果服务，负责查询和格式化单个回测数据
- **StatisticsService**：统计服务，负责计算和返回整体策略指标
- **ChartDataService**：图表数据服务，负责将K线数据转换为前端图表所需格式

**业务逻辑层组件**：
- **数据查询逻辑**：实现分页查询、条件筛选、排序等数据检索功能
- **指标聚合逻辑**：实现胜率计算、收益统计、回撤分析等统计指标计算
- **图表数据转换**：将K线数据格式化为Chart.js所需格式，标注关键点位

**离线回测层组件**：
- **回测管理命令**：Django管理命令入口，提供CLI接口执行批量回测
- **批量回测器**：负责筛选异常事件、调度回测任务、处理错误和进度反馈
- **回测引擎**：核心算法，实现价格分析、指标计算等回测逻辑

**数据层组件**：
- **KLine**：现有历史K线数据，提供价格数据源
- **VolumeTrapMonitor**：现有异常事件记录，提供回测输入
- **BacktestResult**：新增单个回测结果存储，持久化分析结果
- **BacktestStatistics**：新增整体统计数据存储，持久化聚合指标

### 组件与需求映射

---
#### 离线回测层
**负责实现**:
- [PRD 3.1.1] 单个事件回测分析：VolumeTrapBacktestEngine执行价格表现分析
- [PRD 3.1.2] 批量回测分析：BatchBacktestRunner执行批量回测，支持筛选条件
- [PRD 3.1.2] 输出结果：成功/失败统计、错误详情、观察期信息
- [PRD 3.1.3] 整体统计指标：批量回测完成后计算聚合统计

#### API层 + 服务层
**负责实现**:
- [PRD 3.2.1] 回测结果查询API：单个详情查询、批量查询、整体统计
- [PRD 3.2.1] API功能：统一响应格式、分页排序、关键指标返回
- [PRD 3.2.1] 验收标准：API响应格式统一，支持分页和排序

#### 前端页面组件
**负责实现**:
- [PRD 3.2.2] 回测结果详情页：K线图表、关键指标面板、数据表格
- [PRD 3.2.2] 验收标准：图表清晰标注关键点位，指标展示直观易读
- [PRD 3.2.3] 整体统计面板：指标卡片、收益分布图、回撤分析、分组统计
- [PRD 3.2.3] 验收标准：数据展示层次清晰，支持数据导出

#### BacktestResult & BacktestStatistics 模型
**负责实现**:
- [PRD 3.1.1] 数据持久化：单个事件回测结果存储
- [PRD 3.1.3] 数据持久化：整体统计结果存储
- [PRD 3.1] 验收标准：计算结果存储到数据库

#### 图表数据服务
**负责实现**:
- [PRD 3.2.2] K线图表展示：将回测结果转换为Chart.js可用的K线数据格式
- [PRD 3.2.2] 关键点标注：在图表上标记入场点、最低点、反弹点
---

### 交互说明

**离线回测流程**：
1. **触发回测**：执行`python manage.py run_backtest`管理命令
2. **筛选事件**：根据条件筛选VolumeTrapMonitor记录
3. **批量回测**：BatchBacktestRunner遍历异常事件，调用VolumeTrapBacktestEngine
4. **价格分析**：回测引擎获取K线数据，计算最低点、反弹、最大回撤等指标
5. **结果存储**：回测结果保存到BacktestResult和BacktestStatistics表

**在线展示流程**：
1. **用户访问**：前端页面发起API请求
2. **数据查询**：服务层查询BacktestResult或BacktestStatistics表
3. **数据转换**：将数据库数据转换为JSON格式或图表数据
4. **前端渲染**：前端页面渲染图表和表格，展示回测结果

**关键数据流**：
- **单个回测数据流**：VolumeTrapMonitor → VolumeTrapBacktestEngine → BacktestResult → API → 前端详情页
- **整体统计数据流**：BacktestResult集合 → StatisticsCalculator → BacktestStatistics → API → 前端统计面板
- **K线图表数据流**：BacktestResult + KLine → ChartDataService → Chart.js格式 → 前端K线图

---

## 阶段三：关键决策点与方案评估

### 决策点一：回测执行方式（同步 vs 异步）

**方案A：同步执行**
- 简介：直接在API调用或管理命令中执行回测，等待所有计算完成
- 优点：实现简单，调试方便，无需额外基础设施
- 缺点：API响应时间长（可能超过60秒），容易超时；批量回测时用户体验差

**方案B：异步执行**
- 简介：使用Celery异步任务队列，回测任务提交到队列后立即返回任务ID，用户可轮询查看进度
- 优点：API响应快速，支持长时间任务，用户体验好，可扩展性强
- 缺点：需要配置Celery和消息代理（Redis/RabbitMQ），增加系统复杂度

**✅ 最终选择：离线脚本方案**
- 使用离线脚本执行回测并存储结果，网页只负责展示回测结果
- 理由：架构简单，性能稳定，无超时风险，适合批量处理，避免复杂的异步任务系统

---

### 决策点二：K线数据查询优化策略

**方案A：原始SQL聚合**
- 简介：直接使用Django ORM查询，获取所有K线后在Python中计算
- 优点：逻辑清晰，易于调试和理解
- 缺点：可能产生N+1查询问题，大量数据传输到Python内存，性能较低

**方案B：数据库聚合函数**
- 简介：使用数据库的MAX、MIN等聚合函数直接在SQL中计算最低点、最高点
- 优点：数据库层面优化性能，减少数据传输
- 缺点：复杂查询逻辑可能难以维护，部分计算逻辑（如反弹检测）仍需在Python中实现

**方案C：混合策略**
- 简介：数据获取使用优化查询（prefetch_related），计算逻辑在Python中实现，但使用批量处理减少查询次数
- 优点：平衡性能和可维护性，利用Django ORM优势
- 缺点：仍需传输较多数据到内存，但已通过prefetch_related优化

**✅ 最终选择：方案C（混合策略）**
- 理由：满足PRD性能要求（单个回测<2秒），通过合理索引和查询优化可达；保持代码可读性和维护性

---

### 决策点三：前端图表展示方案

**方案A：Chart.js**
- 简介：轻量级图表库，直接在Django Template中集成
- 优点：集成简单，文件体积小，满足K线图基本需求，文档完善
- 缺点：K线图需要额外插件（chartjs-chart-financial），交互性相对简单

**方案B：Plotly.js**
- 简介：功能强大的交互式图表库
- 优点：交互性极佳，内置K线图支持，缩放、平移等操作流畅
- 缺点：文件体积大（>1MB），加载速度慢，可能影响页面性能

**方案C：ECharts**
- 简介：百度开源图表库，国内开发者社区活跃
- 优点：K线图支持完善，性能优秀，文档详细，中文支持好
- 缺点：需要学习特定API，与现有前端体系可能不一致

**✅ 最终选择：方案A（Chart.js）**
- 理由：满足PRD基本需求（K线图标注关键点），实现成本低；文件体积小，页面加载速度快，符合性能要求

---

## 阶段四：最终架构方案

### 系统架构总结

本系统采用**离线回测 + 在线展示**的分离式架构，具有以下特点：

1. **职责清晰**：离线层负责计算，在线层负责展示
2. **性能稳定**：避免API超时风险，支持大规模数据批量处理
3. **架构简单**：无需异步任务基础设施，降低系统复杂度
4. **易于维护**：数据持久化存储，支持增量更新和历史回溯

### 技术栈选择

- **后端框架**：Django + Django REST Framework
- **数据库**：PostgreSQL/MySQL（现有）
- **前端图表**：Chart.js + chartjs-chart-financial（K线图插件）
- **回测执行**：Django管理命令（离线批处理）
- **数据查询**：Django ORM + prefetch_related（混合策略）

### 部署架构

```
┌─────────────────┐
│   用户浏览器     │
└────────┬────────┘
         │
┌────────▼────────┐     ┌──────────────────┐
│   Django Web   │────▶│   PostgreSQL     │
│   (前端+API)    │     │   (数据存储)     │
└────────┬────────┘     └──────────────────┘
         │
┌────────▼────────┐
│  管理命令执行   │
│ python manage.py│
│   run_backtest  │
└─────────────────┘
```

### 性能预期

- **单个回测分析**：< 2秒（满足PRD要求）
- **批量回测（1000条）**：约60秒（离线执行，无超时风险）
- **API查询响应**：< 1秒（满足PRD要求）
- **页面加载时间**：< 3秒（Chart.js轻量级）

### 扩展性考虑

- **水平扩展**：通过数据库索引优化和读写分离，支持更大数据量
- **功能扩展**：预留参数优化、报告导出等P2功能的扩展空间
- **集成扩展**：通过标准API接口，可与现有Volume Trap系统无缝集成

---

## 验收标准

### 功能验收
- [ ] 所有P0功能测试通过（单个事件回测、批量回测、整体统计）
- [ ] API接口功能完整（详情查询、批量查询、统计查询）
- [ ] 页面展示正确（K线图标注、指标面板、统计图表）

### 性能验收
- [ ] 单次回测分析响应时间 < 2秒
- [ ] 批量回测1000条记录完成时间 < 60秒
- [ ] 统计查询响应时间 < 1秒
- [ ] 页面加载时间 < 3秒

### 集成验收
- [ ] 与现有系统集成无冲突
- [ ] 数据迁移顺利
- [ ] 数据库模型创建成功

---

✅ P4 架构设计完成

📄 遵循四阶段工作流程:
  ✓ 阶段一：需求解读与目标对齐
  ✓ 阶段二：架构设计与可视化
  ✓ 阶段三：关键决策点与方案评估
  ✓ 阶段四：最终架构方案定稿

📄 输出文档:
  └── docs/iterations/007-backtest-framework/architecture.md (完整架构设计文档)

🔒 质量门禁 Gate 4: 架构设计清晰性
  ✓ 系统架构明确 (Mermaid图表)
  ✓ 模块职责清晰
  ✓ 组件与需求映射完整
  ✓ 关键决策点分析完成
  ✓ 最终方案选择确认
  ✓ 技术栈选择合理
  ✓ 性能预期明确

🎯 下一步: 进入 /powerby.plan 阶段，生成详细实现计划
