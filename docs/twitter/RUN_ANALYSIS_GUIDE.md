# 🚀 一键分析命令使用指南

## 概述

`run_analysis` 命令是集成了**自动缓存**和**智能分析**的一体化解决方案。只需一个命令，即可完成推文收集和 AI 分析的全流程。

## ✨ 核心特性

### 🔄 自动缓存机制
- **智能时间计算**：自动获取数据库中该 List 的最新推文时间
- **增量收集**：只获取比最新推文更晚的内容，避免重复
- **可选禁用**：支持 `--no-cache` 强制全量收集

### 🎯 智能分析策略
- **新推文模式**：有新增推文时，分析所有新推文
- **历史模式**：无新推文时，分析最近 200 条历史推文
- **自动模板选择**：根据 List ID 自动匹配提示词模板

### 💰 成本优化
- **精准控制**：每次只分析必要数量的推文
- **实时显示**：展示预估成本和实际成本
- **JSON 验证**：自动验证分析结果格式

## 📋 命令语法

```bash
python manage.py run_analysis <list_id> [选项]
```

### 必需参数
- `list_id`: Twitter List ID

### 可选参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `--hours` | 24 | 获取最近 N 小时的推文 |
| `--batch-size` | 500 | 每批获取的推文数量（50-1000） |
| `--no-cache` | False | 禁用缓存，获取所有推文 |
| `--collect-only` | False | 仅收集推文，不执行分析 |
| `--dry-run` | False | 试运行模式（不保存到数据库） |

## 🎮 使用示例

### 1. 基本使用（推荐）
```bash
# 一键分析，自动缓存
python manage.py run_analysis 1939614372311302186

# 指定时间范围
python manage.py run_analysis 1939614372311302186 --hours 48

# 指定批次大小
python manage.py run_analysis 1939614372311302186 --batch-size 200
```

### 2. 仅收集模式
```bash
# 只收集推文，不分析
python manage.py run_analysis 1939614372311302186 --collect-only --hours 48
```

### 3. 禁用缓存
```bash
# 强制全量收集（重新获取所有历史推文）
python manage.py run_analysis 1988517245048455250 --no-cache --hours 48
```

### 4. 试运行
```bash
# 不保存到数据库，预览操作
python manage.py run_analysis 1939614372311302186 --dry-run --hours 24
```

## 📊 实际案例

### 案例 1：项目机会分析（List 1939614372311302186）

**场景**：日常投资分析，关注项目机会

```bash
python manage.py run_analysis 1939614372311302186 --hours 24
```

**输出示例**：
```
============================================================
🚀 一键分析（自动缓存 + 分析）
============================================================
List ID: 1939614372311302186
模式: 缓存模式
收集范围: 最近 24 小时
============================================================
📋 使用现有 TwitterList: List 1939614372311302186 - 项目机会分析

============================================================
📥 步骤 1: 收集推文（自动缓存）
============================================================
✅ 使用缓存：从 2025-11-14 07:49:29 开始获取
   数据库最新推文时间: 2025-11-14 07:54:29

时间范围: 2025-11-14 07:49:29 ~ 2025-11-14 07:58:30
时间跨度: 0.2 小时

📥 收集结果
============================================================
处理批次数: 1
总获取推文数: 3
新保存推文数: 3

============================================================
🔍 步骤 2: 执行分析
============================================================
📊 分析模式: 新推文增量分析

待分析推文数量: 3 条
分析时间范围: 2025-11-14 07:53:29 ~ 2025-11-14 07:54:29

✅ 自动选择模板: 项目机会分析 (项目机会分析)

============================================================
✅ 分析完成
============================================================
任务 ID: 9b3deb3a-20d4-4d56-a3ed-1bb7259b182a
推文数量: 3
实际成本: $0.0002
处理时长: 14.08 秒
分析状态: ✅ 成功
分析结果: ✅ 格式正确（字典类型）

============================================================
✨ 任务完成
============================================================
✅ 推文收集完成
✅ AI 分析完成

📊 查看结果:
   python check_result.py  # 查看最新分析结果
```

### 案例 2：市场情绪分析（List 1988517245048455250）

**场景**：市场情绪监控

```bash
python manage.py run_analysis 1988517245048455250 --hours 48
```

**特点**：
- 🎯 自动选择"市场情绪分析"模板
- 📈 恐惧贪婪指数分析
- 💰 成本更低：约 $0.0005
- ⚡ 处理速度快：45 秒

## 🔍 缓存机制详解

### 工作原理
1. **查询数据库**：获取该 List 的最新推文时间
2. **计算开始时间**：最新推文时间 - 5 分钟缓冲
3. **只获取新推文**：从缓存时间点开始获取
4. **避免重复**：使用数据库去重机制

### 缓存效果
```
缓存前：获取 24 小时 × N 条推文
缓存后：获取 0.2 小时 × N 条推文

效率提升：120倍
```

### 禁用缓存
使用 `--no-cache` 强制全量收集：
- 适用于：初次使用、数据同步、故障恢复
- 注意事项：成本和时间都会增加

## 🎨 智能分析策略

### 新推文模式（默认）
**条件**：有新增推文被收集

**行为**：
- 分析范围：从缓存时间开始到现在
- 优点：精准、节省成本
- 适用：日常增量分析

### 历史模式（无新推文时）
**条件**：没有新推文被收集

**行为**：
- 分析范围：最近 200 条历史推文
- 优点：确保分析连续性
- 适用：定期回顾、历史数据分析

## 💡 最佳实践

### 1. 日常使用
```bash
# 每天运行一次
python manage.py run_analysis 1939614372311302186

# 或指定更长时间范围
python manage.py run_analysis 1939614372311302186 --hours 48
```

### 2. 定时任务
```bash
# 添加到 crontab
# 每天凌晨 2 点运行
0 2 * * * cd /path/to/project && python manage.py run_analysis 1939614372311302186 --hours 24
```

### 3. 多 List 管理
```bash
# 项目机会分析 List
python manage.py run_analysis 1939614372311302186 --hours 24

# 市场情绪分析 List
python manage.py run_analysis 1988517245048455250 --hours 24
```

### 4. 成本控制
```bash
# 降低批次大小（减少 API 调用）
python manage.py run_analysis 1939614372311302186 --batch-size 100

# 缩短时间范围
python manage.py run_analysis 1939614372311302186 --hours 12
```

## 🔧 故障排除

### 1. 没有新推文
**现象**：收集结果为 0 条新推文

**原因**：
- 缓存时间点之后没有新推文
- 网络问题或 API 限制

**解决**：
```bash
# 检查缓存是否正确
python manage.py run_analysis <list_id> --dry-run

# 强制全量收集
python manage.py run_analysis <list_id> --no-cache
```

### 2. 分析失败
**现象**：分析步骤出现错误

**常见原因**：
- 推文数量为 0
- 成本超限
- AI API 错误

**解决**：
```bash
# 仅收集，不分析
python manage.py run_analysis <list_id> --collect-only

# 检查模板配置
python manage.py shell -c "from twitter.models import PromptTemplate; print(PromptTemplate.get_template_for_list('<list_id>'))"
```

### 3. 性能问题
**现象**：命令执行缓慢

**优化方案**：
- 减小批次大小：`--batch-size 100`
- 缩短时间范围：`--hours 12`
- 启用缓存：避免全量收集

## 📈 与原命令对比

| 功能 | 原命令 | run_analysis |
|------|--------|--------------|
| 收集推文 | `collect_twitter_list` | ✅ 内置 |
| 分析推文 | `analyze_twitter_list` | ✅ 内置 |
| 自动缓存 | ❌ | ✅ 智能缓存 |
| 手动指定时间 | ✅ | ✅ |
| 模板选择 | 手动指定 | ✅ 自动选择 |
| 成本控制 | 手动配置 | ✅ 自动优化 |
| 一条命令完成 | ❌ | ✅ |

## 🎯 总结

`run_analysis` 命令简化了 Twitter 分析的工作流程：

1. **更简单**：一条命令完成所有操作
2. **更智能**：自动缓存和模板选择
3. **更高效**：避免重复获取，节省时间和成本
4. **更灵活**：支持多种模式和参数组合

**推荐使用方式**：
```bash
# 日常使用
python manage.py run_analysis <list_id>

# 定期分析
python manage.py run_analysis <list_id> --hours 48

# 故障恢复
python manage.py run_analysis <list_id> --no-cache
```

🚀 **现在就开始使用吧！**
